#!/usr/bin/env bash
#
# oneshot | run a command on remote hosts
# requires: bash 4.0+, ssh, gnu sed

trap 'echo -e "\nSIGINT Received... exiting"; exit 130' SIGINT

err() {
  # handle errors (send to standard error)
  echo "$*" >&2
}

show_help() {
  # help text
  echo "Usage: ${0##*/} [-a|-c] [-u <username>] <hostfile> \"<command>\""
  echo "Options:"
  echo "  -h, --help    Show this help menu"
  echo "  -a            Show output in 'view' format, with line-breaks"
  echo "  -c            Show output in CSV format {hostname},{output}"
  echo "  -u <user>     Specify SSH username"
}

_parse_options_prevent_me() {
  # called in parse_options()
  # prevents mutually exclusive options from being requested in the same command
  # uses $mutually_exclusive_options
  if [[ "$mutually_exclusive_options" ]]; then
    err "Conflicting options (-a) and (-c) both used."
    echo "---"
    show_help
    exit 1
  fi
}

parse_options() {
  # check for long "--help"
  if [[ "$1" == "--help" ]]; then
    show_help
    exit 0
  fi

  # set a local variable that prevents mutually exclusive options
  # use with _parse_options_prevent_me function
  local mutually_exclusive_options=
  local opt

  while getopts "hacu:" opt; do
    case "$opt" in
      h) show_help; exit 0 ;;
      a)
        _parse_options_prevent_me
        format_style="1"
        mutually_exclusive_options="1"
        ;;
      c)
        _parse_options_prevent_me
        format_style="2"
        mutually_exclusive_options="1"
        ;;
      u) username="$OPTARG" ;;
      \?)
        err "Invalid option: -$OPTARG"
        show_help
        exit 1
        ;;
    esac
  done
}

file2array() {
  # convert each line in a file to an array element
  # skip lines that start with # or [, skip blank lines
  # trim leading and trailing whitespace
  # ARGS: $1 = array_name, $2 = filename
  # RET: array
  readarray -t "$1" < \
            <(sed -E '/^[#\[]|^$/d; s/^[[:space:]]+|[[:space:]]+$//g' "$2")
}

### main script flow
# parse options and arguments; assign values
declare format_style="0"
declare username="${USER}"
parse_options "$@"
shift $((OPTIND - 1)) # shift $@ past optional flags

# check for at least two arguments in after options are evaluated
if [[ $# -ne 2 ]]; then
  err "Two arguments required: <hostlist> \"<command>\""
  echo "---"
  show_help
  exit 1
fi

# check for $1, the hostfile, valid path
if [[ ! -f "$1" ]]; then
  err "$1 not found. Please validate hostlist path"
  exit 3
fi

# declare an array to iterate through for command
declare -a host_array
# place the hostfile into an array, parsing using file2array
file2array "host_array" "$1"

# assemble the commands to pass into ssh, add "true" to handle ssh errors
declare -a cmd_array=("${@:2}" "2>&1" "||" "true")

# adhere to format style chosen, and use ssh to run command(s) on remote hosts
case "$format_style" in
  0)
    # no formatting, just passing stdout
    for hostname in "${host_array[@]}"; do
      cmd_output=$(ssh -nq -o StrictHostKeychecking=no -o ConnectTimeout=10 \
                       "${username}"@"${hostname}" "${cmd_array[@]}")
      if [[ $? -eq 255 ]]; then
        err "Connection to ${hostname} failed"
      else
        echo "$cmd_output"
      fi
    done
    ;;
  1)
    # "-a", hostname and then a line break, extra blank line at end
    for hostname in "${host_array[@]}"; do
      echo "${hostname}:"
      cmd_output=$(ssh -nq -o StrictHostKeychecking=no -o ConnectTimeout=10 \
                       "${username}"@"${hostname}" "${cmd_array[@]}")
      if [[ $? -eq 255 ]]; then
        err "Connection to ${hostname} failed"
      else
       echo "$cmd_output"
      fi
      echo ""
    done
    ;;
  2)
    # "-c", csv format: {hostname},{stdout}
    echo "hostname,output"
    for hostname in "${host_array[@]}"; do
      echo -n "${hostname},"
      cmd_output=$(ssh -nq -o StrictHostKeychecking=no -o ConnectTimeout=10 \
                       "${username}"@"${hostname}" "${cmd_array[@]}")
      if [[ $? -eq 255 ]]; then
        err "Connection to ${hostname} failed"
      else
        echo "$cmd_output"
      fi
    done
    ;;
esac
