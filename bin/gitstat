#!/usr/bin/env bash
#
# gitstat | find git repos and print git status
# requires: bash 3.2+, git, find

declare magenta="\033[0;35m"
declare reset="\033[0m"

trap 'echo -e "\nSIGINT Received... exiting"; exit 130' SIGINT

err() {
  # handle errors (send to standard error)
  echo "$*" >&2
}

show_help() {
  # help text
  echo "Usage: ${0##*/} [-d <top level directory>] [-e <excluded directory>]"
  echo "Options:"
  echo "  -h, --help    Show this help menu"
  echo "  -d <dir>      Specify the top level directory to search from"
  echo "  -i <dir>      Ignore a specific directory from results (repeatable)"
}

parse_options() {
  # check for long "--help"
  if [[ "$1" == "--help" ]]; then
    show_help
    exit 0
  fi

  local opt
  while getopts ":hd:i:" opt; do
    case "$opt" in
      h) show_help; exit 0 ;;
      d)
        top_dir="$OPTARG"
        if [[ ! -d "${top_dir}" ]]; then
          err "Directory not found: ${top_dir}"
          echo
          show_help
          exit 1
        fi
        ;;
      # strip trailing '/' from the argument if present
      i)
        local exd
        exd="${OPTARG%/}"
        if [[ ! "${exd}" =~ ^(/|\.\.?/) ]]; then
          exd="./${exd}"
        fi
        excluded_dirs+=("${exd}")
        ;;
      \?)
        err "Invalid option: -$OPTARG"
        show_help
        exit 1
        ;;
    esac
  done
}

_check_excluded_dirs() {
  # MODIFY -> excluded_dirs (array)
  # iterate through the excluded directories array and validate
  # remove from excluded_dirs array if non-valid
  local d
  for ((d=0; d<${#excluded_dirs[@]}; d++)); do
    if [[ ! -d "${excluded_dirs[$d]}" ]]; then
      err "Directory not found: ${excluded_dirs[$d]}... omitting"
      unset "excluded_dirs[$d]"
      ((d--))
    fi
  done
}

fetch_git_repos() {
  # find all .git repositories under $1 path and place them into the array
  local repo_dir
  while IFS= read -r repo_dir; do
    git_repos+=("${repo_dir}")
  done < <(find "$1" -type d -name ".git" -exec dirname {} \; 2>/dev/null)
}

_remove_excluded_dirs() {
  # MODIFY -> git_repos (array) VIA -> excluded_dirs (array)
  # removes directories stated in excluded_dirs from git_repos
  local d
  # Iterate over repo_dirs
  for d in "${excluded_dirs[@]}"; do
    # shellcheck disable=SC2206
    git_repos=(${git_repos[@]/${d}*})
  done
}

### main script flow
# parse options
declare top_dir
declare -a excluded_dirs
parse_options "$@"

# check for existance of $top_dir;
# if it wasn't set by an argument, set it to pwd
if [[ -z "$top_dir" ]]; then
  top_dir=.
fi

# validate excluded directories variable, removing invalid arguments
_check_excluded_dirs

# fetch the git repositories and assign to git_repos
declare -a git_repos
fetch_git_repos "$top_dir"

# remove excluded directories from git_repos
_remove_excluded_dirs

# iterate through the array created in fetch_git_repos() and show git status
for r in "${git_repos[@]}"; do
  printf -- "--- "
  printf "${magenta}%s${reset}\n" "${r%%\/.git}"
  cd "${r}" || exit 1
  git status
  printf -- "---\n\n"
  cd - >/dev/null 2>&1 || exit 1
done
