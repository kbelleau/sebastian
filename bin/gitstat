#!/usr/bin/env bash
#
# gitstat :: find git repos and print git status
# requires: bash 3.2+, git, find

trap 'echo -e "\nSIGINT Received... exiting"; exit 130' SIGINT

# global variables
declare magenta="\033[0;35m"
declare reset="\033[0m"

err() {
  # handle errors (send to standard error)
  echo "$*" >&2
}

show_help() {
  # help option text
  echo "Usage: ${0##*/} [-d <top level directory>] [-e <excluded directory>]"
  echo "Options:"
  echo "  -h, --help    Show this help menu"
  echo "  -d <dir>      Specify the top level directory to search from"
  echo "  -i <dir>      Ignore a specific directory from results (repeatable)"
  echo "  -l            Only list git repos, and skip default action"
}

parse_options() {
  # parse arguments and assign variables, arrays

  # check for long "--help"
  if [[ "$1" == "--help" ]]; then
    show_help
    exit 0
  fi

  local opt
  while getopts ":hd:i:l" opt; do
    case "$opt" in
      h) show_help; exit 0 ;;
      d)
        top_dir="$OPTARG"
        if [[ ! -d "${top_dir}" ]]; then
          err "Directory not found: ${top_dir}"
          echo
          show_help
          exit 1
        fi
        ;;
      i)
        # strip trailing '/' from the argument if present
        local s
        s="${OPTARG%/}"
        if [[ ! "${s}" =~ ^(/|\.\.?/) ]]; then
          s="./${s}"
        fi
        excluded_dirs+=("${s}")
        ;;
      l) opt_list="1" ;;
      \?)
        err "Invalid option: -$OPTARG"
        show_help
        exit 1
        ;;
    esac
  done
}

_fetch_git_repos() {
  # find all .git repositories under $1 path and place them into an array
  #
  # ARG: $1 directory
  # RET: git_repos

  local d
  while IFS= read -r d; do
    git_repos+=("${d}")
  done < <(find "$1" -type d -name ".git" -exec dirname {} \; 2>/dev/null)
}

_check_excluded_dirs() {
  # check excluded directories and remove from excluded_dirs array if non-valid
  #
  # MOD: excluded_dirs (array)

  local d
  for ((d=0; d<${#excluded_dirs[@]}; d++)); do
    if [[ ! -d "${excluded_dirs[$d]}" ]]; then
      err "Directory not found: ${excluded_dirs[$d]}."
      unset "excluded_dirs[$d]"
      ((d--))
    fi
  done
}

_remove_excluded_dirs() {
  # removes directories stated in excluded_dirs from git_repos
  #
  # MOD: git_repos (array) USE: excluded_dirs (array)

  local d
  # Iterate over git_repos
  for d in "${excluded_dirs[@]}"; do
    # shellcheck disable=SC2206
    git_repos=(${git_repos[@]/${d}*})
  done
}

gitstat_list() {
  # iterate through found git repos and print their paths
  #
  # ARG: $1 git_repos (array)

  local d
  for d in "$@"; do
    echo "$d"
  done
}

gitstat_run() {
  # iterate through found git repos and print their git status
  #
  # ARG: $1 git_repos (array)

  local d
  for d in "$@"; do
    printf -- "--- "
    printf "${magenta}%s${reset}\n" "${d%%\/.git}"
    cd "${d}" || exit 1
    git status
    printf -- "---\n\n"
    cd - >/dev/null 2>&1 || exit 1
  done
}

main() {
  # parse options
  local opt_list
  local top_dir
  local -a excluded_dirs
  parse_options "$@"

  # check for existance of $top_dir;
  # if it wasn't set by an argument, set it to pwd
  if [[ -z "$top_dir" ]]; then
    top_dir=.
  fi

  # fetch the git repositories and assign to git_repos
  local -a git_repos
  _fetch_git_repos "$top_dir"

  # validate excluded_dirs array, removing invalid arguments
  _check_excluded_dirs

  # remove excluded directories from git_repos
  _remove_excluded_dirs

  # run list output if specified
  if [[ "$opt_list" -eq 1 ]]; then
    gitstat_list "${git_repos[@]}"
    exit 0
  fi

  # run primary output
  gitstat_run "${git_repos[@]}"
}

main "$@"
